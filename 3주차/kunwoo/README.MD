# 1번 풀이
문제를 보고 **완전 탐색**으로 구현해야겠다 생각이 들어서, **DFS(깊이 우선탐색)**로 문제를 해결하였다.   
배열을 돌면서 깊이(depth)가 배열의 길이와 같아질때 목표로 하는 **target**이 **sum**과 같아질때 answer에 1을 더하는 방식이고, depth가 배열의 길이와 같지 않을때는 재귀 함수호출(여기서는 +와 - 두 개의 함수)을 통해 배열의 길이와 같아질때까지 루프를 돌린다.
</br>

위의 로직을 그림으로 나타내면 다음과 같다. (예시는 numbers가 [1,2,3]일 경우)

![image](https://user-images.githubusercontent.com/75151693/209518972-d6360479-231f-4fab-8e4d-9d5b1aa7f85b.png)
 
</br>

# 2번 풀이
여러가지 풀이가 있겠지만, 해쉬를 사용해서 문제를 해결하고 싶어 해쉬 자료형을 사용하여 해결하였다.   

문제해결 코드는 아래와 같은 로직을 따른다.   

1. 전화번호는 중복이 없기에, HashSet 자료구조로 객체를 생성하였고, 배열의 원소들을 먼저 add해주었다.   

2. phone_book 배열을 순차적으로 돌면서, 뽑은 원소의 0번째 자리부터 (1 ~ 마지막-1 자리)까지 차례차례 substring해준것이 set에 담은 원소들과 비교(contains메소드)하여 일치하는 것이 있다면 return false, 없다면 return true해준다.
=> 마지막-1자리 까지 substring하는 이유는 **자기자신을 비교하면 안되기 때문**

<br>

# 3번 풀이
큐를 사용하여 선입선출(먼저 넣은 데이터를 먼저 가져오는 구조)방식으로 데이터를 처리했다.   

문제해결 로직은 아래와 같다.
1. 다리에 올라가있는 트럭을 Queue라고 정하고, Queue가 비어있으면 배열에서 데이터를 가져와서 Queue에 삽입한다.
2. 다리에 트럭을 한대 추가할 때, 다리에 올라가 있는 트럭의 총 무게(=sum)에 트럭의 무게를 더해주고, 시간+1을 해준다.   
3. 만약, 다리에 올라가 있는 트럭의 개수가 다리에 올릴수 있는 최대 허용 트럭 개수(=bride_length)와 같다면, 다리에서 트럭을 한대 제거해주고, sum에서 그 무게를 뺸다.(sum -= q.poll())   
4. 다리에 올라가 있는 트럭 개수가 최대 허용치를 넘지 않았다면, 두 가지 케이스로 나눠야 하는데, 다음 트럭이 최대 무게허용치(=weight)를 넘지 않을때와 넘었을 때로 구분한다.   
5. 최대 무게허용치를 넘었을때는, Queue에 0을 삽입하는데, 이유는 최대 허용 트럭 개수를 맞추기 위함이다.   
=> 최대 허용 트럭 개수를 맞춰야 다리에서 트럭을 빼서 다음 트럭을 넣을 수 있기 때문   
6. 최대 무게허용치를 넘지 않았을 때는, 배열에서 다음 트럭을 Queue에 삽입해주고, sum에 그 무게를 더하고, 시간+1을 해준다.   
7. 최종 걸린 시간은 마지막 트럭이 다리에 진입했을때부터 다리 길이만큼 시간초를 더해줘야 하므로 return answer+ 다리길이(bride_length)를 해준다.   

