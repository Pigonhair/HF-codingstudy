# 1번 풀이
문제를 보고 **완전 탐색**으로 구현해야겠다 생각이 들어서, **DFS**(깊이 우선탐색)로 문제를 해결하였다.   
배열을 돌면서 깊이(depth)가 배열의 길이와 같아질때 목표로 하는 **target**이 **sum**과 같아질때 answer에 1을 더하는 방식이고, depth가 배열의 길이와 같지 않을때는 재귀 함수호출(여기서는 +와 - 두 개의 함수)을 통해 배열의 길이와 같아질때까지 루프를 돌린다.
</br>

위의 로직을 그림으로 나타내면 다음과 같다. (예시는 numbers가 [1,2,3]일 경우)

![image](https://user-images.githubusercontent.com/75151693/209518972-d6360479-231f-4fab-8e4d-9d5b1aa7f85b.png)
 
</br>

# 2번 풀이
여러가지 풀이가 있겠지만, 해쉬를 사용해서 문제를 해결하고 싶어 해쉬 자료형을 사용하여 해결하였다.   

문제해결 코드는 아래와 같은 로직을 따른다.   

1. 전화번호는 중복이 없기에, HashSet 자료구조로 객체를 생성하였고, 배열의 원소들을 먼저 add해주었다.   

2. phone_book 배열을 순차적으로 돌면서, 뽑은 원소의 0번째 자리부터 (1 ~ 마지막-1 자리)까지 차례차례 substring해준것이 set에 담은 원소들과 비교(contains메소드)하여 일치하는 것이 있다면 return false, 없다면 return true해준다.
=> 마지막-1자리 까지 substring하는 이유는 **자기자신을 비교하면 안되기 때문**
